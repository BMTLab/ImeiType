# .github/workflows/ci-build.yml

# Reusable build pipeline for .NET:
# - Restores in locked mode (packages.lock.json), caches tools, enables MSBuild matcher.
# - Builds, runs tests with XPlat coverage, merges reports, evaluates a coverage gate,
#   and packs NuGet packages (symbols + source).
# - Publishes artifacts: coverage-report/* and artifacts/package/release/*.nupkg.
# Writes clear GitHub Summary sections for restore, coverage, and packaged outputs.
# No secrets required; safe for PRs and branch pushes.

name: Build, Test & Pack CI

on:
  workflow_call:

jobs:
  build:
    name: Build Project
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      checks: write # to create annotations on PRs
    env:
      ### Directories
      DOTNET_TOOLS: ~/.dotnet/tools
      TEST_RESULTS: test-results
      COVERAGE_REPORT: coverage-report
      MUTATION_REPORT: mutation-report
      PACKAGE_RELEASE: artifacts/package/release

      ### Performance / noise (safe in CI)
      DOTNET_NOLOGO: true
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      # Disable MSBuild node reuse so worker processes don't linger across steps.
      # Equivalent to msbuild /nr:false:
      MSBUILDDISABLENODEREUSE: ${{ vars.MSBUILDDISABLENODEREUSE || '0' }}
      # Skip downloading NuGet xml docs (IntelliSense) during restore to reduce IO & bandwidth:
      NUGET_XMLDOC_MODE: ${{ vars.NUGET_XMLDOC_MODE || 'skip' }}

      ### Testing
      # Coverage gate:
      MIN_LINE_COVERAGE: ${{ vars.MIN_LINE_COVERAGE || '50' }} # %
      # Toggle for optional mutation testing safeguard step (Stryker):
      RUN_MUTATION_TESTS: ${{ vars.RUN_MUTATION_TESTS || 'true' }}
      # Mutation gate:
      MIN_MUTATION_TESTS_SCORE: ${{ vars.MIN_MUTATION_TESTS_SCORE || '50' }}

      ### Error/exit code:
      ERR_LOCKFILES_CHANGED: 11
      ERR_COVERAGE_GATE_FAIL: 12
      ERR_NO_LEGACY_SOLUTION: 13
      ERR_MUTATION_GATE_FAIL: 14
      STRYKER_EXIT_BELOW_THRESHOLD: 2

    steps:
      ### Setup
      - name: ‚öô Checkout
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0 # full history is safer for tools that read history (e.g., GitVersion)

      - name: ‚öô Resolve .NET Tools Path
        # Make sure the global dotnet tools directory is on PATH for subsequent steps.
        run: |
          echo "DOTNET_TOOLS=${HOME}/.dotnet/tools" >> "$GITHUB_ENV"
          echo "${HOME}/.dotnet/tools" >> "$GITHUB_PATH"

      - name: ‚öô Setup .NET
        # Installs multiple SDKs and enables built-in NuGet cache by packages.lock.json
        uses: actions/setup-dotnet@v5.0.0
        with:
          dotnet-version: |
            9.0.x
            8.0.x
            7.0.x
            6.0.x
          cache: true
          cache-dependency-path: '**/packages.lock.json'

      - name: ‚ÑπÔ∏è Display .NET Version
        run: dotnet --info

      - name: üß∞ Cache .NET Tools
        # Caches the global dotnet tools (e.g., reportgenerator, gitversion)
        uses: actions/cache@v4.3.0
        with:
          path: ${{ env.DOTNET_TOOLS }}
          key: ${{ runner.os }}-dotnet-tools-${{ hashFiles('**/dotnet-tools.json') }}
          restore-keys: |
            ${{ runner.os }}-dotnet-tools-

      - name: ü™õ Install .NET Tools
        run: dotnet tool restore

      - name: üß© Restore Dependencies
        # Locked mode ensures restore uses the committed lock files (reproducible builds).
        run: |
          set -o errexit -o nounset -o pipefail

          echo '::group::dotnet restore (locked-mode)'
          dotnet restore --locked-mode
          echo '::endgroup::'
          echo "::notice title=Restore completed::Mode=locked; NUGET_XMLDOC_MODE=${NUGET_XMLDOC_MODE}"
          #######################################################

      - name: ü™™ Enable MSBuild problem matcher
        # Adds a custom problem matcher so msbuild-style warnings/errors produce PR annotations.
        # The regex is tolerant to optional trailing [Project] in the message.
        run: |
          set -o errexit -o nounset -o pipefail

          cat > "${RUNNER_TEMP}/msbuild-matcher.json" <<'JSON'
          {
            "problemMatcher": [
              {
                "owner": "msbuild-cs",
                "pattern": [
                  {
                    "regexp": "^(.+?\\.\\w+)\\((\\d+),(\\d+)\\): (warning|error) ([A-Z]{2,}\\d{4}): (.+?)(?: \\[.*\\])?$",
                    "file": 1,
                    "line": 2,
                    "column": 3,
                    "severity": 4,
                    "code": 5,
                    "message": 6
                  }
                ]
              }
            ]
          }
          JSON
          echo "::add-matcher::${RUNNER_TEMP}/msbuild-matcher.json"
          echo '::notice title=Problem matcher enabled::owner=msbuild-cs'
        continue-on-error: true

      - name: üîí Verify Package Lockfiles Unchanged
        # Guardrail: if restore would update any packages.lock.json, fail early with a diff.
        run: |
          set -o errexit -o nounset -o pipefail

          echo '::group::Lockfile check'
          if git status --porcelain | grep -F 'packages.lock.json' >/dev/null 2>&1; then
            echo '::error title=packages.lock.json changed::Lock files changed during restore. Commit updated lock files'
            git diff -- '**/packages.lock.json' || true
            echo '::endgroup::'
            exit "$ERR_LOCKFILES_CHANGED"
          else
            echo '::notice title=Lockfiles::No lockfile changes detected'
            echo '::endgroup::'
          fi
          #######################################################

      - name: üîç Capture Version Info (GitVersion)
        id: gitversion
        # Captured as a step output so summary can consume it independently.
        # The step never fails the job; if GitVersion isn't available, we still proceed.
        run: |
          set -o errexit -o nounset -o pipefail

          {
            echo 'json<<EOF'
            dotnet gitversion /output json
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          #######################################################

      - name: üìä Summary - Build Info
        if: ${{ always() }}
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = 'Stop'

          echo "## üìä Build Information" >> $env:GITHUB_STEP_SUMMARY
          if ('${{ steps.gitversion.outputs.json }}') {
            $gv = '${{ steps.gitversion.outputs.json }}' | ConvertFrom-Json
            echo "| Property | Value |" >> $env:GITHUB_STEP_SUMMARY
            echo "|---|---|" >> $env:GITHUB_STEP_SUMMARY
            echo ("| Version | **{0}** |" -f $gv.SemVer) >> $env:GITHUB_STEP_SUMMARY
            echo ("| Branch | `{0}` |" -f $gv.BranchName) >> $env:GITHUB_STEP_SUMMARY
            echo ("| Commit | `{0}` |" -f $gv.Sha.Substring(0,7)) >> $env:GITHUB_STEP_SUMMARY
          } else {
            echo "‚ö†Ô∏è GitVersion data not available" >> $env:GITHUB_STEP_SUMMARY
          }
        shell: pwsh


      ### Build
      - name: üõ†Ô∏è Build
        # If build fails, the job will normally fail here;
        # downstream "always()" steps still run and summarize.
        run: >-
          dotnet build
          -c Release
          --no-restore

      - name: üîß Rebuild (verbose) on failure
        # Fallback path with more diagnostics and optional custom cleaning script.
        if: ${{ failure() }}
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = 'Stop'

          echo "::warning title=Fallback rebuild::First build failed; running verbose rebuild"
          if (Test-Path ./scripts/clean.ps1) {
            Write-Host "::group::Cleaning"
            ./scripts/clean.ps1
            Write-Host "::endgroup::"
          }
          Write-Host "::group::dotnet build (verbose)"
          dotnet build -c Release --verbosity detailed
          Write-Host "::endgroup::"
        shell: pwsh

      - name: üßπ Disable MSBuild matcher
        if: ${{ always() }}
        run: echo '::remove-matcher owner=msbuild-cs::'
        continue-on-error: true


      ### Test & Coverage
      - name: üîß Ensure ReportGenerator tool
        # Try update first to keep the global tool fresh; fallback to install.
        run: >-
          dotnet tool update -g dotnet-reportgenerator-globaltool
          || dotnet tool install -g dotnet-reportgenerator-globaltool

      - name: üß™ Test + Coverage (via XPlat Cobertura)
        run: |
          set -o errexit -o nounset -o pipefail
          echo '## üß™ Test Results' >> "$GITHUB_STEP_SUMMARY"

          echo '::group::dotnet test'
          # Note: the space after the last double dash (--) is intentional
          dotnet test -c Release --no-build -v minimal \
            --results-directory "./${TEST_RESULTS}" \
            --collect:'XPlat Code Coverage;Format=cobertura' \
            --logger 'GitHubActions;annotations.titleFormat=@test [@framework];summary.includePassedTests=true' \
            -- \
            RunConfiguration.CollectSourceInformation=true
          echo '::endgroup::'
          #######################################################

      - name: ü§ù Merge Coverage Reports
        # Runs even if tests failed; if there are no coverage files, create target dir and warn.
        if: ${{ always() }}
        run: |
          set -o errexit -o nounset -o pipefail
          shopt -s globstar nullglob

          files=( "$TEST_RESULTS"/**/coverage.cobertura.xml )
          
          echo '::group::reportgenerator'
          echo "Coverage files detected, count=${#files[@]}"
          if ((${#files[@]})); then
            reportgenerator \
              -reports:"${TEST_RESULTS}/**/coverage.cobertura.xml" \
              -targetdir:"$COVERAGE_REPORT" \
              -reporttypes:'Cobertura;HtmlInline_AzurePipelines_Dark;MarkdownSummaryGithub;TextSummary'
          else
            echo "::warning title=Coverage::No coverage.cobertura.xml files found under $TEST_RESULTS"
            mkdir -p "$COVERAGE_REPORT"
          fi
          echo '::endgroup::'
          #######################################################

      - name: üßÆ Evaluate Coverage Gate
        id: coverage_eval
        # Non-failing evaluation step that computes % and threshold compliance.
        # Results are written to step outputs for use by both the summary and the enforcement step.
        if: ${{ always() }}
        run: |
          set -o errexit -o nounset -o pipefail

          #######################################
          # Parses Cobertura.xml and extracts line coverage (%).
          #
          # Arguments (read-only):
          #   1: coverage_path                - Path to Cobertura.xml.
          # Outputs (by reference, via nameref):
          #   2: _pct                         - Line coverage percent with 2 decimals (string), e.g. "78.34".
          #   3: _found                       - 'true' if file exists, else 'false'.
          #   4: _has_rate_attr               - 'true' if line-rate attr was found, else 'false'.
          # Returns:
          #   0 - Always.
          #######################################
          function parse_cobertura_line_rate() {
            local -r coverage_path="$1"
            local -n _pct="$2"
            local -n _found="$3"
            local -n _has_rate_attr="$4"

            _pct='0.00'
            _found=false
            _has_rate_attr=false

            if [[ -f "$coverage_path" ]]; then
              _found=true
              local rate=''
              rate="$(grep -oP '(?<=line-rate=")[0-9.]+' "$coverage_path" | head -n 1 || true)"
              if [[ -n "$rate" ]]; then
                _pct="$(awk -v r="$rate" 'BEGIN{printf "%.2f", r*100}')"
                _has_rate_attr=true
              fi
            fi
          }

          #######################################
          # Compares coverage vs threshold.
          #
          # Arguments (read-only):
          #   1: pct                          - Coverage percent as string (e.g. "78.34").
          #   2: min_threshold                - Minimal acceptable percent (integer/number string).
          # Outputs (by reference, via nameref):
          #   3: _meets                       - 'true' if pct >= min_threshold, else 'false'.
          # Returns:
          #   0 - Always.
          #######################################
          function coverage_meets_threshold() {
            local -r pct="$1"
            local -r min_threshold="$2"
            local -n _meets="$3"

            if awk -v a="$pct" -v b="$min_threshold" 'BEGIN{exit !(a>=b)}'; then
              _meets=true
            else
              _meets=false
            fi
          }

          #######################################
          # Writes step outputs to $GITHUB_OUTPUT.
          #
          # Arguments (read-only):
          #   1: found                        - 'true' / 'false'
          #   2: pct                          - Percent string "NN.NN"
          #   3: meets                        - 'true' / 'false'
          #   4: reason                       - Diagnostic reason string
          # Returns:
          #   0 - Always.
          #######################################
          function write_gate_outputs() {
            local -r found="$1"
            local -r pct="$2"
            local -r meets="$3"
            local -r reason="$4"
            {
              echo "found=${found}"
              echo "pct=${pct}"
              echo "meets=${meets}"
              echo "reason=${reason}"
            } >> "$GITHUB_OUTPUT"
          }

          cov_path="${COVERAGE_REPORT}/Cobertura.xml"
          pct='0.00'
          found=false
          has_rate=false
          meets=false
          reason='report-not-found'

          parse_cobertura_line_rate "$cov_path" pct found has_rate

          if [[ "$found" == true ]]; then
            if [[ "$has_rate" == true ]]; then
              min="${MIN_LINE_COVERAGE:-0}"
              coverage_meets_threshold "$pct" "$min" meets
              reason=$([[ "$meets" == true ]] && echo 'ok' || echo 'below-threshold')
              echo "::notice title=Coverage parsed::line-rate=${pct}% min=${min}%"
            else
              reason='line-rate-missing'
            fi
          fi

          # Export output:
          write_gate_outputs "$found" "$pct" "$meets" "$reason"

          # Log results:
          case "$reason" in
            ok)
              echo "::notice title=Coverage gate passed::${pct}% ‚â• ${MIN_LINE_COVERAGE:-0}%"
              ;;
            below-threshold)
              echo "::warning title=Coverage below threshold::${pct}% < ${MIN_LINE_COVERAGE:-0}%"
              ;;
            report-not-found)
              echo "::warning title=Coverage::Cobertura.xml not found at ${cov_path}"
              ;;
            line-rate-missing)
              echo '::warning title=Coverage::line-rate attribute not found in Cobertura.xml'
              ;;
          esac
          #######################################################

      - name: üö¶ Enforce Coverage Gate
        # This is the only failing step in the gate flow.
        if: >-
          ${{ steps.coverage_eval.outputs.found == 'true'
          && steps.coverage_eval.outputs.meets != 'true' }}
        run: |
          set -o errexit -o nounset -o pipefail

          echo "::error title=Coverage gate failed::${{ steps.coverage_eval.outputs.pct }}% < ${MIN_LINE_COVERAGE}%"
          exit "$ERR_COVERAGE_GATE_FAIL"
          #######################################################

      - name: üì§ Upload Coverage Artifacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ env.COVERAGE_REPORT }}-${{ github.sha }}
          path: ${{ env.COVERAGE_REPORT }}/**
          if-no-files-found: warn
          retention-days: 30

      - name: üß¨ Mutation Testing (Stryker)
        id: stryker
        if: ${{ env.RUN_MUTATION_TESTS == 'true' }}
        run: |
          set -o errexit -o nounset -o pipefail

          #######################################
          # Finds a single legacy solution file './*.sln.old' in repo root.
          #
          # Outputs (by reference, via nameref):
          #   1: _sln_old                     - Path to legacy solution.
          # Returns:
          #   0                               - Found.
          #   $ERR_NO_LEGACY_SOLUTION         - Not found.
          #######################################
          function find_legacy_solution() {
            local -n _sln_old="$1"
            _sln_old=''

            shopt -s nullglob
            local -a candidates=( ./*.sln.old )
            if [[ ${#candidates[@]} -eq 0 ]]; then
              return "$ERR_NO_LEGACY_SOLUTION"
            fi

            _sln_old="${candidates[0]}"
            return 0
          }

          #######################################
          # Activates legacy solution: backs up existing *.sln (if any) and renames *.sln.old -> *.sln.
          #
          # Arguments (read-only):
          #   1: sln_old                      - Path to '*.sln.old'.
          # Outputs (by reference, via nameref):
          #   2: _sln                         - Activated '*.sln' path.
          #   3: _backup                      - Backup path of pre-existing '*.sln' (if any), else empty.
          # Returns:
          #   0 - Always.
          #######################################
          function activate_legacy_solution() {
            local -r sln_old="$1"
            local -n _sln="$2"
            local -n _backup="$3"

            _sln="${sln_old%.old}"
            _backup=''

            if [[ -f "$_sln" ]]; then
              _backup="${_sln}.bak-ci-$$"
              mv -f "$_sln" "$_backup"
            fi

            mv -f "$sln_old" "$_sln"
          }

          #######################################
          # Reverts activation done by activate_legacy_solution().
          #
          # Arguments (read-only):
          #   1: sln_old                      - Path to '*.sln.old' (may not exist yet).
          #   2: sln                          - Active '*.sln' path (if exists).
          #   3: backup                       - Backup path to restore (if exists).
          # Returns:
          #   0 - Always (idempotent).
          #######################################
          function revert_solution_activation() {
            local -r sln_old="$1"
            local -r sln="$2"
            local -r backup="$3"

            # Put legacy file back if we had activated it:
            if [[ -n "$sln" && -f "$sln" && -n "$sln_old" && ! -f "$sln_old" ]]; then
              mv -f "$sln" "$sln_old" || true
            fi

            # Restore original *.sln if a backup exists:
            if [[ -n "$backup" && -f "$backup" ]]; then
              mv -f "$backup" "$sln" || true
            fi
          }

          #######################################
          # Runs Stryker and captures its exit code without failing the shell.
          #
          # Outputs (by reference, via nameref):
          #   1: _rc                          - Exit code returned by 'dotnet stryker'.
          # Returns:
          #   0 - Always.
          #######################################
          function run_stryker() {
            local -n _rc=$1
            set +e
            dotnet stryker \
              --break-at "$MIN_MUTATION_TESTS_SCORE" \
              --mutation-level 'Advanced' \
              --reporter 'Markdown' \
              --reporter 'Html' \
              --output "$MUTATION_REPORT"
            _rc=$?
            set -e
          }

          #######################################
          # Resolves Stryker report paths if present.
          #
          # Arguments (read-only):
          #   1: base_dir                     - Stryker output base (e.g., "$MUTATION_REPORT").
          # Outputs (by reference, via nameref):
          #   2: _report_dir                  - "<base_dir>/reports" if exists else empty.
          #   3: _report_md                   - "<_report_dir>/mutation-report.md" if exists else empty.
          # Returns:
          #   0 - Always.
          #######################################
          function resolve_stryker_reports() {
            local -r base_dir="$1"
            local -n _report_dir="$2"
            local -n _report_md="$3"

            _report_dir="${base_dir}/reports"
            _report_md="${_report_dir}/mutation-report.md"

            if [[ ! -f "$_report_md" ]]; then
              _report_dir=''
              _report_md=''
            fi
          }

          sln_old=''
          sln=''
          backup=''

          echo '::group::Prepare solution'
          if ! find_legacy_solution sln_old; then
            rc="$ERR_NO_LEGACY_SOLUTION"
            echo "::error title=Stryker::No '*.sln.old' found in repository root"
            {
              echo 'activated_sln='
              echo 'report_dir='
              echo 'report_md='
              echo "exit_code=${rc}"
            } >> "$GITHUB_OUTPUT"
            echo '::endgroup::'
            exit "$rc"
          fi

          activate_legacy_solution "$sln_old" sln backup
          echo "Activated solution: $(basename "$sln")"
          echo '::endgroup::'

          # Always revert changes at the end (success or failure).
          function _cleanup() { revert_solution_activation "$sln_old" "$sln" "$backup"; }
          trap _cleanup EXIT
          
          # Fresh output directory:
          rm -rf "$MUTATION_REPORT"

          echo '::group::dotnet stryker'
          rc=0
          run_stryker rc
          echo "Stryker exit code: $rc"
          echo '::endgroup::'
          
          report_dir=''
          report_md=''
          resolve_stryker_reports "$MUTATION_REPORT" report_dir report_md
          if [[ -n "$report_md" ]]; then
            echo "::notice title=Stryker::${report_md}"
          else
            echo "::warning title=Stryker::Markdown report not found at ${MUTATION_REPORT}/reports/mutation-report.md"
          fi

          # Export outputs for downstream steps (artifacts + summary + gate):
          {
            echo "activated_sln=$(basename "$sln")"
            echo "report_dir=$report_dir"
            echo "report_md=$report_md"
            echo "exit_code=$rc"
          } >> "$GITHUB_OUTPUT"

          _cleanup

          # Allow only 0 (OK) and $STRYKER_EXIT_BELOW_THRESHOLD (score < --break-at) to pass this step:
          if [[ $rc -eq 0 || $rc -eq $STRYKER_EXIT_BELOW_THRESHOLD ]]; then
            exit 0
          fi

          echo "::error title=Stryker::Unexpected exit code=${rc} (not a threshold failure). See logs above"
          exit "$rc"
          #######################################################

      - name: üì§ Upload Stryker Artifacts
        if: >-
          ${{ always()
          && env.RUN_MUTATION_TESTS == 'true'
          && steps.stryker.outputs.report_dir != '' }}
        uses: actions/upload-artifact@v4.6.2
        with:
          name: ${{ env.MUTATION_REPORT }}-${{ github.sha }}
          path: ${{ steps.stryker.outputs.report_dir }}/**
          if-no-files-found: warn
          retention-days: 30

      - name: üö¶ Enforce Mutation Gate
        # Stryker returns non-zero STRYKER_EXIT_BELOW_THRESHOLD exit code when score < --break-at.
        if: >-
          ${{ env.RUN_MUTATION_TESTS == 'true'
          && steps.stryker.outputs.exit_code == env.STRYKER_EXIT_BELOW_THRESHOLD }}
        run: |
          set -o errexit -o nounset -o pipefail

          msg="Mutation gate failed, the score below ${MIN_MUTATION_TESTS_SCORE}% "
          msg+='(exit code=${{ steps.stryker.outputs.exit_code }})'
          echo "::error title=Stryker::${msg}"
          
          exit "$ERR_MUTATION_GATE_FAIL"
          #######################################################


      ### Summaries (always-on)
      - name: üìä Summary - Coverage (with details)
        if: ${{ always() }}
        run: |
          set -o errexit -o nounset -o pipefail

          md="${COVERAGE_REPORT}/SummaryGithub.md"
          txt="${COVERAGE_REPORT}/Summary.txt"

          {
            echo '### üìù Code Coverage'
            if [[ '${{ steps.coverage_eval.outputs.found }}' == 'true' ]]; then
              echo "Line coverage: **${{ steps.coverage_eval.outputs.pct }}%** (min: ${MIN_LINE_COVERAGE}%)"
            else
              echo '‚ö†Ô∏è `Cobertura.xml` not found'
            fi

            echo
            if [ -f "$md" ]; then
              # Demote headings inside the generated Markdown so it nests under our header nicely:
              sed -E \
                -e 's/^# Summary$/ /' \
                -e 's/^## Coverage/###### Coverage/' \
                "$md"
            else
              echo '‚ö†Ô∏è Coverage markdown summary not found'
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          #######################################################

      - name: üìä Summary - Mutation Testing
        if: ${{ always() }}
        run: |
          set -o errexit -o nounset -o pipefail

          md='${{ steps.stryker.outputs.report_md }}'
          exit_code='${{ steps.stryker.outputs.exit_code }}'
          {
            echo '### üß¨ Mutation Testing (Stryker)'
            echo "_Exit code:_ **${exit_code}**"
            echo
            if [[ -n "$md" && -f "$md" ]]; then
              tail -n +2 "$md" \
              | tr -d '#' \
              | sed -E 's/\\\//\//g'
            else
              echo '‚ö†Ô∏è Stryker Markdown report not found'
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          #######################################################


      ### Pack
      - name: üì¶ Pack Packages
        # Using --no-build assumes the previous build step succeeded; if build failed earlier,
        # this step will fail quickly (and summaries still run thanks to always()).
        run: |
          set -o errexit -o nounset -o pipefail

          echo "::group::dotnet pack -> $PACKAGE_RELEASE"
          {
            dotnet pack \
              -c Release \
              --no-build \
              --include-symbols \
              --include-source
          }
          echo '::endgroup::'
          #######################################################

      - name: üì§ Upload Packages Artifacts
        uses: actions/upload-artifact@v4.6.2
        with:
          name: packages-${{ github.sha }}
          path: ${{ env.PACKAGE_RELEASE }}/**
          if-no-files-found: error
          retention-days: 30

      - name: üìä Summary - Packages
        if: ${{ always() }}
        run: |
          set -o errexit -o nounset -o pipefail

          {
            echo '## üì¶ Packaged Artifacts'
            shopt -s nullglob

            # Collect .nupkg into an array and sort by filename:
            files=( "${PACKAGE_RELEASE}"/*.nupkg )
            if [ ${#files[@]} -eq 0 ]; then
              echo '‚ö†Ô∏è No packages were created'
            else
              # We leave only the file names and sort:
              IFS=$'\n' read -r -d '' -a sorted < <(printf '%s\n' "${files[@]##*/}" | sort && printf '\0')

              # Numbered list:
              i=1
              for name in "${sorted[@]}"; do
                echo "${i}. \`${name}\`"
                i=$((i+1))
              done
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          #######################################################