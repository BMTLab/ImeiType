# .github/workflows/ci-pack.yml

# Builds the repo (via the shared setup-project composite), generates Markdown release notes
# from Git history, injects them into NuGet `PackageReleaseNotes`, packs *.nupkg/*.snupkg,
# uploads artifacts, and prints a human-friendly summary.
#
# Release notes generation:
# - Fetches tags (handles shallow clones) and resolves the previous version-like tag `v*.*.*`,
#   excluding the current tag on tag runs.
# - Collects up to MAX_RELEASE_NOTES_LINES commit subjects (no merges) since the previous tag;
#   falls back to ‚ÄúInitial release‚Äù when no previous tag exists.
# - Writes `artifacts/package/release/ReleaseNotes.md` (same folder as packed artifacts),
#   which MSBuild (see Directory.Build.targets) consumes automatically.
# - Builds a ‚ÄúFull changelog‚Äù link using `<repo>/compare/<prev>...<current|HEAD>`.
#
# Packaging:
# - Runs `dotnet pack -c Release --no-build` (build happens in the setup-project action).
# - `PackageReleaseNotes` is populated from the generated ReleaseNotes.md before `GenerateNuspec`.
# - Output directory is controlled by MSBuild and expected at `artifacts/package/release`.
#
# Compatibility:
# - Works for `push`, `pull_request`, and tag-push events.

name: Package CI

on:
  workflow_call:

jobs:
  pack:
    name: Pack NuGet
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      checks: write

    env:
      ### Directories
      PACKAGE_RELEASE: artifacts/package/release
      PACKAGE_RELEASE_NOTES: artifacts/package/release/ReleaseNotes.md

    steps:
      - name: ‚öôÔ∏è Checkout
        uses: actions/checkout@v5.0.0
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: üîß Setup project
        uses: ./.github/actions/setup-project

      # Build a short markdown changelog since the previous version-like tag.
      - name: üìù Generate Release Notes
        env:
          REPO_URL: ${{ github.server_url }}/${{ github.repository }}
          HEAD_SHA: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.sha }}
          CURRENT_TAG: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || '' }}
          MAX_RELEASE_NOTES_LINES: ${{ vars.MAX_RELEASE_NOTES_LINES || '50' }}
        run: |
          set -o errexit -o errtrace -o nounset -o pipefail
          shopt -s nullglob

          : "${REPO_URL:?is not set}"; : "${HEAD_SHA:?is not set}"

          #######################################
          # Ensures `git tag` reflects remote tags.
          #
          # Behavior:
          #   - Detects shallow clones and adds --unshallow when necessary.
          #   - Tolerates fetch failures (continues with local refs, emits a warning).
          # Returns:
          #   0 - Always (non-fatal warnings possible).
          #######################################
          function ensure_git_tags_available() {
            echo '::group::Fetch tags (ensure full history)'

            local shallow_state=''
            if git rev-parse --is-shallow-repository >/dev/null 2>&1; then
              shallow_state="$(git rev-parse --is-shallow-repository)"
            fi

            local -a fetch_args=(--tags --prune-tags)
            if [[ "$shallow_state" == true ]]; then
              fetch_args+=(--unshallow)
            fi

            if ! git fetch "${fetch_args[@]}"; then
              echo '::warning title=Fetch tags::Failed to refresh tags; continuing with existing refs'
            fi

            echo '::endgroup::'
          }

          #######################################
          # Resolves the previous version-like tag (e.g., v1.2.3 or v1.2.3-rc),
          # excluding the current tag (when running on a tag push).
          #
          # Outputs (by reference via nameref):
          #   1: _tag (string) - Receives the tag or empty if not found.
          # Returns:
          #   0 - Always.
          #######################################
          function resolve_previous_tag() {
            local -n _tag="$1"
            local tag=''

            tag="$(git describe --tags --abbrev=0 --match 'v[0-9]*.[0-9]*.[0-9]*' ${CURRENT_TAG:+--exclude "$CURRENT_TAG"} 2>/dev/null || true)"
            if [[ -z "$tag" ]]; then
              tag="$(git describe --tags --abbrev=0 ${CURRENT_TAG:+--exclude "$CURRENT_TAG"} 2>/dev/null || true)"
            fi
            _tag="$tag"
          }

          #######################################
          # Collects commit subjects into an array (no merges), optionally for a RANGE.
          #
          # Arguments (read-only):
          #   1: range (string)       - e.g., 'v1.2.3..HEAD' or empty for full history.
          # Outputs (by reference via nameref):
          #   2: _lines (array)       - Receives up to MAX_RELEASE_NOTES_LINES formatted lines.
          # Returns:
          #   0 - Always.
          #######################################
          function collect_commits() {
            local -r range="$1"
            local -n _lines="$2"

            mapfile -t _lines < <(
              git log --no-merges --pretty='- %s (%h)' ${range:+$range} \
                | head -n "$MAX_RELEASE_NOTES_LINES" \
              || true
            )
          }

          #######################################
          # Writes markdown release notes file.
          #
          # Arguments (read-only):
          #   1: prev_tag (string)              - Previous version tag or empty.
          #   2: _lines (array, ref)            - Commit lines to write.
          # Returns:
          #   0 - Always.
          #######################################
          function write_notes() {
            local -r prev_tag="$1"
            local -n _lines="$2"

            {
              echo '### Changes'
              echo
              if [[ -n "$prev_tag" ]]; then
                echo "_Changes since ${prev_tag}:_"
                echo
              fi

              if ((${#_lines[@]} > 0)); then
                printf '%s\n' "${_lines[@]}"
              else
                echo '- Initial release'
              fi

              echo
              if [[ -n "$prev_tag" ]]; then
                local -r right_ref="${CURRENT_TAG:-$HEAD_SHA}"
                echo "Full changelog: ${REPO_URL}/compare/${prev_tag}...${right_ref}"
              fi
            } > "$PACKAGE_RELEASE_NOTES"
          }

          echo '::group::Prepare'
          mkdir -p "$PACKAGE_RELEASE"
          ensure_git_tags_available

          echo "Artifacts dir: $PACKAGE_RELEASE"
          echo "Output file: $PACKAGE_RELEASE_NOTES"
          echo "Current tag (if any): ${CURRENT_TAG:-'(none)'}"
          echo '::endgroup::'

          prev_tag=''
          resolve_previous_tag prev_tag

          range=''
          if [[ -n "$prev_tag" ]]; then
            range="${prev_tag}..HEAD"
          fi

          commits=()
          collect_commits "$range" commits
          write_notes "$prev_tag" commits

          # Brief preview into the job summary:
          {
            echo '## üìù Release Notes (preview)'
            echo
            if [[ -n "$prev_tag" ]]; then
              echo "_Changes since ${prev_tag}_"
            else
              echo '_Initial release (no previous tag found)_'
            fi
            echo
            if ((${#commits[@]} > 0)); then
              printf '%s\n' "${commits[@]}"
            else
              echo '- (no commits captured)'
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          echo "::notice title=Release notes::Wrote $PACKAGE_RELEASE_NOTES with ${#commits[@]} line(s)"
          #######################################################

      # Pack all projects that define pack targets in the repo.
      - name: üì¶ Pack Packages
        run: |
          set -o errexit -o nounset -o pipefail

          echo "::group::dotnet pack -> $PACKAGE_RELEASE"
          {
            dotnet pack \
              -c Release \
              --no-build \
              --include-symbols \
              --include-source
          }
          echo '::endgroup::'
          #######################################################

      # Upload packaged artifacts for downstream consumption.
      - name: üì§ Upload Packages Artifacts
        uses: actions/upload-artifact@v5.0.0
        with:
          name: packages-${{ github.sha }}
          path: ${{ env.PACKAGE_RELEASE }}/**
          if-no-files-found: error
          retention-days: 30

      # Human-friendly list of produced packages in the job summary.
      - name: üìä Summary - Packages
        if: ${{ always() }}
        run: |
          set -o errexit -o nounset -o pipefail

          {
            echo '## üì¶ Packaged Artifacts'
            shopt -s nullglob

            # Collect .nupkg into an array and sort by filename:
            files=("${PACKAGE_RELEASE}"/*.nupkg)
            if [ ${#files[@]} -eq 0 ]; then
              echo '‚ö†Ô∏è No packages were created'
            else
              # Keep only file names and sort:
              IFS=$'\n' read -r -d '' -a sorted < <(printf '%s\n' "${files[@]##*/}" | sort && printf '\0')

              # Numbered list:
              i=1
              for name in "${sorted[@]}"; do
                echo "${i}. \`${name}\`"
                i=$((i+1))
              done
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          #######################################################